
#include <map>
#include <sstream>
#include <string>
#include <vector>

#include "builder.h"
#include "logger.h"
#include "macros.h"

namespace d2d {

void PrintUsage(bool error = false) {
  std::stringstream stream;
  stream << R"~~~(

Convert Doxygen Documentation to a Dash or Zeal Docset.

Usage
=====

  doxgen2docset --doxygen <path to doxygen source> --docset <path to docset dir> [--help]

Options
=======

  --doxygen       Required: The path the HTML sources generated by Doxygen,
                  see the explanatory section below on how to configure Doxygen.

  --docset        Required: The path to the directory where this tool will
                  generate the docset. The name of the docset will be derived
                  from the Docset bundle identifier. For example, if the
                  Docset bundle identifer is, "com.exmple.docs", a docset
                  named "com.exmple.docs.docset" will be generated in this
                  directory.

                  To configure the docset bundle identifier, set the
                  DOCSET_BUNDLE_ID property in your Doxyfile before generating
                  documentation.

  --help          Print this documentation.

Preparing Doxygen for Docsets
=============================

* In the Doxyfile for your project, make sure the following options are set:
  * GENERATE_DOCSET = YES
  * GENERATE_HTML   = YES
* Invoke Doxygen to generate HTML documentation. On a successful invocation
  of doxygen with the required flags, the html/ directory should be generated.
  * This tool depends on reading the following files generated by Doxygen. If
    these files are absent, the docset cannot be generated.
    * Tokens.xml
    * Info.plist

)~~~";

  if (error) {
    D2D_ERROR << stream.str();
  } else {
    D2D_LOG << stream.str();
  }
}

class ArgParser {
 public:
  ArgParser(const std::vector<std::string> &args) {
    for (size_t i = 0; i < args.size(); i++) {
      if (args[i].find_first_of("--") == 0) {
        if (i < args.size() - 1 && args[i + 1].find_first_of("--") != 0) {
          args_[args[i].substr(2)] = args[i + 1];
        } else {
          args_[args[i].substr(2)] = "";
        }
      }
    }
  }

  bool HasRequiredOptions() const {
    return args_.count("doxygen") == 1 && args_.count("docset") == 1;
  }

  bool HasOption(const std::string &option) const {
    return args_.count(option) == 1;
  }

  std::string GetDoxygenPath() const { return args_.at("doxygen"); }

  std::string GetDocsetPath() const { return args_.at("docset"); }

 private:
  std::map<std::string, std::string> args_;
  D2D_DISALLOW_COPY_AND_ASSIGN(ArgParser);
};

bool Main(const std::vector<std::string> &args) {
  ArgParser parser(args);

  if (parser.HasOption("help")) {
    PrintUsage();
    return true;
  }

  if (!parser.HasRequiredOptions()) {
    D2D_ERROR << "User error: Required options absent. See usage....";
    PrintUsage(true);
    return false;
  }

  D2D_LOG << "Packing Docs:     " << parser.GetDoxygenPath();
  D2D_LOG << "Output Directory: " << parser.GetDocsetPath();
  D2D_LOG << "Working...";
  auto result = BuildDocset(parser.GetDoxygenPath(), parser.GetDocsetPath());
  D2D_LOG << (result ? "Success." : "Failed.");
  return result;
}

}  // namespace d2d

int main(int argc, char const *argv[]) {
  std::vector<std::string> args;
  for (int i = 1; i < argc; i++) {
    args.emplace_back(argv[i]);
  }
  return d2d::Main(args) ? EXIT_SUCCESS : EXIT_FAILURE;
}
